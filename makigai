#!/bin/sh

# TODO: ability to read from stdin (so db.tsv can be sliced and diced in a particular way and then used as the deck, i.e. custom study sessions in anki)
# TODO: ability to read from stdin for import
# TODO: total recall mode (optional flag value of number of days to review ahead by)
# TODO: patches to either add or remove features (suckless philosophy)
# TODO: add comments to code
# TODO: explain grading system in help
# TODO: remove dependency on bc if possible
# TODO: look to anki's features for inspiration
# TODO: tweak spaced repitition algorithm

create_temp_deck() {
	rm .tostudy.tmp.csv 2> /dev/null
	if [ "$RESCHEDULEFLAG" = "0" ]; then echo "\033[5;31mRescheduling off, deck will not be written to\033[0m"; fi
	AWK_PATTERN="(NR > 1)"
	if [ "$1" != ".*" ]; then AWK_PATTERN="$AWK_PATTERN && (\$4 ~ /$1/)"; fi
	if [ "$3" != "1" ]; then AWK_PATTERN="$AWK_PATTERN && (\$8 <= date)"; fi
	awk -F'\t' -v date="$(date +%Y-%m-%d)" "$AWK_PATTERN" "$2" > .tostudy.tmp.csv
	if [ "$3" != "1" ]; then
		DUE=$(awk -F'\t' -v date="$(date +%Y-%m-%d)" '$8 == date {i++} END {print i}' .tostudy.tmp.csv)	
		PAST_DUE=$(awk -F'\t' -v date="$(date +%Y-%m-%d)" '$8 < date {i++} END {print i}' .tostudy.tmp.csv)
		printf '\033[5;33mDue today: %s card(s)' "$DUE"
		if [ "$PAST_DUE" -gt 0 ]; then printf '\033[5;31m (%s past due)' "$PAST_DUE"; fi
		printf '\033[0m\n'
	else
		NUM_CARDS=$(awk -F'\t' 'END {print NR}' .tostudy.tmp.csv)	
		printf '\033[5;33mTotal recall mode: %s card(s) loaded\n' "$NUM_CARDS"
	fi
}

validate_deck() {
	TOTAL_LINES=$(awk -F'\t' '(NR > 1) {i++} END {print i}' "$1")
	# mawk (default on debian and ubuntu systems) does not support regex repetition braces, which makes ($1 ~ /^[a-f0-9]$/) not work
	# this is why im using these extra two checks with grep
	# the md5 id regex could just use /^[a-f0-9]+$/, but then ids greater or less than 32 chars long would match
	VALID1=$(awk -F'\t' '
		(NR > 1) &&
		(NF == 8) &&
		($4 ~ /^[a-zA-Z0-9,-]*$/) &&
		($5 ~ /^[0-9]+$/) &&
		($6 >= 1.3) &&
		($7 ~ /^[0-9]+$/)   { i++ } END { print i }' "$1")
	VALID2=$(awk -F'\t' 'NR > 1 { print $8 }' "$1" | grep -c "[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}")
	VALID3=$(awk -F'\t' 'NR > 1 { print $1 }' "$1" | grep -c "[a-f0-9]\{32\}")
	if [ "$TOTAL_LINES" = "$VALID1" ] && [ "$TOTAL_LINES" = "$VALID2" ] && [ "$TOTAL_LINES" = "$VALID3" ]; then
		VALID="valid"
	else
		VALID="\033[5;31mDeck invalid\033[0m"
	fi
}

SM2() {
	case $1 in
		0|1|2 )
			REPETITION=0
			INTERVAL=1;;
		3|4|5 )
			if [ $REPETITION = 0 ]; then
				INTERVAL=1

			elif [ $REPETITION = 1 ]; then
				INTERVAL=6

			elif [ $REPETITION -gt 1 ]; then
				INTERVAL=$(echo "(($INTERVAL*$EASINESS) + (1-($INTERVAL*$EASINESS)%1)*(($INTERVAL*$EASINESS)/1 > 1))/1" | bc)
			fi

			EASINESS=$(echo "$EASINESS + (0.1 - (5 - $GRADE) * (0.08 + (5 - $GRADE) * 0.02))" | bc)
			if [ "$(echo "$EASINESS < 1.3" | bc)" = 1 ]
			then
				EASINESS=1.3
			fi
			REPETITION=$(echo "$REPETITION+1" | bc);;

	esac
}

get_date() {
	if [ "$(uname)" = "Linux" ]; then
		DATE=$(date -d "+$INTERVAL days" +%Y-%m-%d)
	else
		DATE=$(date -v +"$INTERVAL""d" +%Y-%m-%d)
	fi
}

review() {
	SEPARATOR="---------------------------------------------------------"
	if [ -f ".tostudy.tmp.csv" ]; then
		echo "Let's review!";
		while IFS="$(printf '\t')" read -r ID FRONT BACK TAGS REPETITION EASINESS INTERVAL DATE <&3; do
			if [ "$ZENFLAG" = "1" ]; then clear; fi
			OLD_LINE="$ID	$FRONT	$BACK	$TAGS	$REPETITION	$EASINESS	$INTERVAL	$DATE"
			echo "$SEPARATOR"
			echo "\033[1;32mFront:\033[0m" "$FRONT"
			printf '\033[3;30mPress enter to show back...\033[0m'
			read -r _
			echo "\033[1;32mBack:\033[0m" "$BACK"
			while ! (echo "$GRADE" | grep -q "^[0-5]$"); do
				printf '\033[1;32mGrade (0-5): \033[0m'
				read -r GRADE
			done

			SM2 "$GRADE"
			unset GRADE
			if [ "$RESCHEDULEFLAG" != "0" ]; then
				get_date
				echo "\033[1;34mRepetition:\033[0m" "$REPETITION" "\033[1;34mEasiness:\033[0m" "$EASINESS" "\033[1;34mInterval:\033[0m" "$INTERVAL" "\033[1;34mDate:\033[0m" "$DATE"
				NEW_LINE="$ID	$FRONT	$BACK	$TAGS	$REPETITION	$EASINESS	$INTERVAL	$DATE"
				sed -i.bu "s/$OLD_LINE/$NEW_LINE/g" "$DECK"
				rm "$DECK".bu
			fi
			if [ "$ZENFLAG" = "1" ]; then
				printf '\033[3;30mPress enter to show next card...\033[0m'
				read -r _
			fi
		done 3< .tostudy.tmp.csv
		echo "$SEPARATOR"
		echo "Done with review!"
		if [ "$RESCHEDULEFLAG" != "0" ]; then rm .tostudy.tmp.csv 2> /dev/null; fi
	else
		echo "Nothing to review!"
	fi
}

tag_select() {
	echo "\033[1;32mAvailable tags:\033[0m"
	awk -F'\t' '{print $4}' "$DECK" | tail -n +2 | tr , '\n' | sort | uniq -c | sort -rn
	printf '\n\033[1;32mTag selection regex (or '\''all'\''): \033[0m'
	read -r TAG
	if [ "$TAG" = "all" ]; then TAG='.*'; fi
	create_temp_deck "$TAG" "$DECK" "$TOTALRECALLFLAG"
}

stats() {
	echo "\033[1;32mAvailable tags:\033[0m"
	awk -F'\t' '{print $4}' "$DECK" | tail -n +2 | tr , '\n' | sort | uniq -c | sort -rn
	echo "\033[1;32mDue dates:\033[0m"
	awk -F'\t' 'NR > 1 {print $8}' "$DECK" | sort | uniq -c
}

deck_select() {
	echo "\033[1;32mAvailable decks:\033[0m"
	ls ./*.tsv
	printf '\n\033[1;32mDeck: \033[0m'
	OLD_DECK=$DECK
	read -r DECK
	validate_deck "$DECK"
	if [ "$VALID" = "valid" ]; then
		TAG='.*'
		create_temp_deck "$TAG" "$DECK" "$TOTALRECALLFLAG"
	else
		echo "$VALID\033[5;31m, switching back to previous deck"
		DECK=$OLD_DECK
	fi
}

import() {
	printf "id\tfront\tback\ttags\trepetition\teasiness\tinterval\tdue\n"
	awk -F'\t' -v date="$(date +%Y-%m-%d)" '{
							OFS=FS;
							system("printf \"$(head -n 1 /dev/random | md5)\t\"");
							print $0, 0, 2.5, 0, date;
						}' "$1"
}

main() {
	while true; do
		printf '\033[1;33m> \033[0m'
		read -r PROMPT_INPUT

		case $PROMPT_INPUT in
			r|review )
				review
				;;
			t|tag )
				tag_select
				;;
			d|deck )
				deck_select
				;;
			s|stats )
				stats
				;;
			h|help )
				printf "type review/r to review
press tag/t for tag select
press deck/d for deck select
press stats/s for stats
press help/h for help
press quit/q to quit\n\n"
				;;
			q|quit )
				echo "Quitting..."; break;;
			* )
				echo "What??";;
		esac
	done
}

DECK='db.tsv'
TAG='.*'

IMPORTFLAG=
TOTALRECALLFLAG=
RESCHEDULEFLAG=
ZENFLAG=
while getopts i:d:f:htrz name
do
    case $name in
    d)
	if [ ! -f "$OPTARG" ]; then
		printf "\033[5;31mNo deck called %s found\033[0m\n" "$OPTARG"
		exit 1;
	else
		DECK="$OPTARG"
	fi
	;;
    i)    
	IMPORTFLAG=1
	IMPORT="$OPTARG";;
    t)
	TOTALRECALLFLAG=1;;
    r)
	RESCHEDULEFLAG=0;;
    z)
	ZENFLAG=1;;
    f)
	TAG="$OPTARG";;
    h|?)
	printf "Usage: %s: [-h] [-t] [-r] [-d deckfile] [-f tagregex] [-i cardfile]
	-h\thelp
	-t\ttotal recall mode (due date ignored)
	-r\tno rescheduling (deck is left unchanged)
	-z\tzen mode (screen clears between each review)
	-d\tselect deck file (default is db.tsv)
	-f\tfilter deck by tag (default is all tags)
	-i\timport mode (takes in tsv of front, back, and tags)\n" "$0"
	exit 2;;
    esac
done
if [ -n "$IMPORTFLAG" ]; then
	import "$IMPORT"
else
	validate_deck "$DECK"
	if [ "$VALID" = "valid" ]; then
		printf 'üêö \033[1;35mmakigai \033[7;35mv0.0.1\n\033[0m\033[2;37mtype h for help\n\033[0m'
		create_temp_deck "$TAG" "$DECK" "$TOTALRECALLFLAG"
		main
	else
		echo "$VALID"
		exit 2
	fi
fi
