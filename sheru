#!/bin/sh

# TODO: ability to read from stdin (so db.tsv can be sliced and diced in a particular way and then used as the deck, i.e. custom study sessions in anki)
# TODO: ability to read from stdin for import
# TODO: stats (number of cards by tag, forecast, reviews per day, other anki features)
        # awk -F'\t' 'NR > 1 {print $4}' db.tsv | tr , '\n' | sort | uniq
        # awk -F'\t' 'NR > 1 {print $4}' db.tsv | tr , '\n' | sort | uniq | xargs -I {} grep -c {} db.tsv
# TODO: evil mode (review regardless of date, i.e. consider all cards due), optional flag value of number of days to review ahead by
# TODO: add comments to code
# TODO: explain grading system in help
# TODO: remove dependency on bc if possible
# TODO: look to anki's features for inspiration
# TODO: tweak spaced repitition algorithm

SEPARATOR="---------------------------------------------------------"

create_temp_deck() {
	rm .tostudy.tmp.csv 2> /dev/null
	awk -F'\t' -v date="$(date +%Y-%m-%d)" '
		BEGIN {
			due=0;
			pastdue=0;
		}

		($8 == date) && ($4 ~ /'"$1"'/) {
			due++;
			print $0 > ".tostudy.tmp.csv";
		}

		$8 < date && ($4 ~ /'"$1"'/) {
			pastdue++;
			print $0 > ".tostudy.tmp.csv";
		}

		END {
			OFS="";
			if (due > 0 || pastdue > 0) {
				printf "\033[5;33mDue: %s card(s)",due;
				if (pastdue > 0) printf " \033[5;31m(%s past due)",pastdue;
				printf "\n\033[0m";
			}
			else
				print "\033[5;32mNo cards due!\033[0m"
		}' "$2"
}

SM2() {
	case $1 in
		0|1|2 )
			REPETITION=0
			INTERVAL=1;;
		3|4|5 )
			if [ $REPETITION = 0 ]; then
				INTERVAL=1

			elif [ $REPETITION = 1 ]; then
				INTERVAL=6

			elif [ $REPETITION -gt 1 ]; then
				INTERVAL=$(echo "(($INTERVAL*$EASINESS) + (1-($INTERVAL*$EASINESS)%1)*(($INTERVAL*$EASINESS)/1 > 1))/1" | bc)
			fi

			EASINESS=$(echo "$EASINESS + (0.1 - (5 - $GRADE) * (0.08 + (5 - $GRADE) * 0.02))" | bc)
			if [ "$(echo "$EASINESS < 1.3" | bc)" = 1 ]
			then
				EASINESS=1.3
			fi
			REPETITION=$(echo "$REPETITION+1" | bc);;

	esac
}

review() {
	if [ -f ".tostudy.tmp.csv" ]; then
		echo "Let's review!";
		while IFS="$(printf '\t')" read -r ID FRONT BACK TAGS REPETITION EASINESS INTERVAL DATE <&3; do
			OLD_LINE="$ID	$FRONT	$BACK	$TAGS	$REPETITION	$EASINESS	$INTERVAL	$DATE"
			echo "$SEPARATOR"
			echo "\033[1;32mFront:\033[0m" "$FRONT"
			printf '\033[3;30mPress enter to show back...\033[0m'
			read -r _
			echo "\033[1;32mBack:\033[0m" "$BACK"
			while ! (echo "$GRADE" | grep -q "^[0-5]$"); do
				printf '\033[1;32mGrade (0-5): \033[0m'
				read -r GRADE
			done

			SM2 "$GRADE"
			unset GRADE

			DATE=$(date -v +"$INTERVAL""d" +%Y-%m-%d)
			echo "\033[1;34mRepetition:\033[0m" "$REPETITION" "\033[1;34mEasiness:\033[0m" "$EASINESS" "\033[1;34mInterval:\033[0m" "$INTERVAL" "\033[1;34mDate:\033[0m" "$DATE"
			NEW_LINE="$ID	$FRONT	$BACK	$TAGS	$REPETITION	$EASINESS	$INTERVAL	$DATE"
			sed -i.bu "s/$OLD_LINE/$NEW_LINE/g" $DECK
			rm $DECK.bu
		done 3< .tostudy.tmp.csv
		echo "$SEPARATOR"
		echo "Done with review!"
		rm .tostudy.tmp.csv 2> /dev/null
	else
		echo "Nothing to review!"
	fi
}

tag_select() {
	echo "\033[1;32mAvailable tags:\033[0m"
	awk -F'\t' '{print $4}' $DECK | tail -n +2 | tr , '\n' | sort | uniq -c | sort -rn
	printf '\n\033[1;32mTag selection regex (or '\''all'\''): \033[0m'
	read -r TAG
	if [ "$TAG" == "all" ]; then TAG='.*'; fi
	create_temp_deck "$TAG" "$DECK"
}

deck_select() {
	echo "\033[1;32mAvailable decks:\033[0m"
	ls *.tsv
	printf '\n\033[1;32mDeck: \033[0m'
	read -r DECK
	TAG='.*'
	create_temp_deck "$TAG" "$DECK"
}

import() {
	printf "id\tfront\tback\ttags\trepetition\teasiness\tinterval\tdue\n"
	awk -F'\t' -v date="$(date +%Y-%m-%d)" '{
							OFS=FS;
							system("printf \"$(head -n 1 /dev/random | md5)\t\"");
							print $0, 0, 2.5, 0, date;
						}' $1
}

main() {
	while true; do
		printf '\033[1;33m> \033[0m'
		read -r PROMPT_INPUT

		case $PROMPT_INPUT in
			r|review )
				review
				;;
			t|tag )
				tag_select
				;;
			d|deck )
				deck_select
				;;
			h|help )
				printf "press r to review\npress t for tag select\npress d for deck select\npress h for help\npress q to quit\n\n"
				;;
			q|quit )
				echo "Quitting..."; break;;
			* )
				echo "What??";;
		esac
	done
}

DECK='db.tsv'
TAG='.*'

DECKFLAG=
IMPORTFLAG=
TAGFLAG=
while getopts i:d:t:h name
do
    case $name in
    d)    DECKFLAG=1
          DECK="$OPTARG";;
    i)    IMPORTFLAG=1
          IMPORT="$OPTARG";;
    t)    TAGFLAG=1
          TAG="$OPTARG";;
    ?|h)   printf "Usage: %s: [-h] [-d deckfile] [-t tagregex] [-i cardfile]\n" $0
          exit 2;;
    esac
done
if [ ! -z "$IMPORTFLAG" ]; then
	import "$IMPORT"
else
	printf 'üêö \033[1;35msheru \033[7;35mv0.0.1\n\033[0m\033[2;37mtype h for help\n\033[0m'
	create_temp_deck "$TAG" "$DECK"
	main
fi
