#!/bin/sh

# TODO: add ability to add cards (add flag -c that takes in a front-back-tags tsv and generates id-rep-easy-interval-date to stdout, this can then be chained with stdin read)
# TODO: support for multiple decks (sheru -d deck.tsv)
# TODO: support for switching decks in prompt
# TODO: ability to read from stdin (so db.tsv can be sliced and diced in a particular way and then used as the deck, i.e. custom study sessions in anki)
# TODO: stats (number of cards by tag, forecast, reviews per day, other anki features)
        # awk -F'\t' 'NR > 1 {print $4}' db.tsv | tr , '\n' | sort | uniq
        # awk -F'\t' 'NR > 1 {print $4}' db.tsv | tr , '\n' | sort | uniq | xargs -I {} grep -c {} db.tsv
# TODO: add comments to code
# TODO: explain grading system in help
# TODO: evil mode (review regardless of date, i.e. consider all cards due)
# TODO: remove dependency on bc if possible
# TODO: look to anki's features for inspiration
# TODO: tweak spaced repitition algorithm

SEPARATOR="---------------------------------------------------------"
printf '🐚 \033[1;35msheru \033[7;35mv0.0.1\n\033[0m\033[2;37mtype h for help\n\033[0m'

create_temp_deck() {
	rm .tostudy.tmp.csv 2> /dev/null
	awk -F'\t' -v date="$(date +%Y-%m-%d)" '
		BEGIN {
			due=0;
			pastdue=0;
		}

		($8 == date) && ($4 ~ /'"$1"'/) {
			due++;
			print $0 > ".tostudy.tmp.csv";
		}

		$8 < date && ($4 ~ /'"$1"'/) {
			pastdue++;
			print $0 > ".tostudy.tmp.csv";
		}

		END {
			OFS="";
			if (due > 0 || pastdue > 0) {
				printf "\033[5;33mDue: %s card(s)",due;
				if (pastdue > 0) printf " \033[5;31m(%s past due)",pastdue;
				printf "\n\033[0m";
			}
			else
				print "\033[5;32mNo cards due!\033[0m"
		}' db.tsv
}

SM2() {
	case $1 in
		0|1|2 )
			REPETITION=0
			INTERVAL=1;;
		3|4|5 )
			if [ $REPETITION = 0 ]; then
				INTERVAL=1

			elif [ $REPETITION = 1 ]; then
				INTERVAL=6

			elif [ $REPETITION -gt 1 ]; then
				INTERVAL=$(echo "(($INTERVAL*$EASINESS) + (1-($INTERVAL*$EASINESS)%1)*(($INTERVAL*$EASINESS)/1 > 1))/1" | bc)
			fi

			EASINESS=$(echo "$EASINESS + (0.1 - (5 - $GRADE) * (0.08 + (5 - $GRADE) * 0.02))" | bc)
			if [ "$(echo "$EASINESS < 1.3" | bc)" = 1 ]
			then
				EASINESS=1.3
			fi
			REPETITION=$(echo "$REPETITION+1" | bc);;

	esac
}

review() {
	if [ -f ".tostudy.tmp.csv" ]; then
		echo "Let's review!";
		while IFS="$(printf '\t')" read -r ID FRONT BACK TAGS REPETITION EASINESS INTERVAL DATE <&3; do
			OLD_LINE="$ID	$FRONT	$BACK	$TAGS	$REPETITION	$EASINESS	$INTERVAL	$DATE"
			echo "$SEPARATOR"
			echo "\033[1;32mFront:\033[0m" "$FRONT"
			printf '\033[3;30mPress enter to show back...\033[0m'
			read -r _
			echo "\033[1;32mBack:\033[0m" "$BACK"
			while ! (echo "$GRADE" | grep -q "^[0-5]$"); do
				printf '\033[1;32mGrade (0-5): \033[0m'
				read -r GRADE
			done

			SM2 "$GRADE"
			unset GRADE

			DATE=$(date -v +"$INTERVAL""d" +%Y-%m-%d)
			echo "\033[1;34mRepetition:\033[0m" "$REPETITION" "\033[1;34mEasiness:\033[0m" "$EASINESS" "\033[1;34mInterval:\033[0m" "$INTERVAL" "\033[1;34mDate:\033[0m" "$DATE"
			NEW_LINE="$ID	$FRONT	$BACK	$TAGS	$REPETITION	$EASINESS	$INTERVAL	$DATE"
			sed -i.bu "s/$OLD_LINE/$NEW_LINE/g" db.tsv
			rm db.tsv.bu
		done 3< .tostudy.tmp.csv
		echo "$SEPARATOR"
		echo "Done with review!"
		rm .tostudy.tmp.csv 2> /dev/null
	else
		echo "Nothing to review!"
	fi
}

tag_select() {
	echo "\033[1;32mAvailable tags:\033[0m"
	awk -F'\t' '{print $4}' db.tsv | tail -n +2 | tr , '\n' | sort | uniq -c | sort -rn
	printf '\n\033[1;32mTag selection regex (or '\''all'\''): \033[0m'
	read -r TAG
	if [ "$TAG" == "all" ]; then TAG='.*'; fi
	create_temp_deck $TAG
}

TAG='.*'
create_temp_deck $TAG
while true; do
        printf '\033[1;33m> \033[0m'
	read -r PROMPT_INPUT

	case $PROMPT_INPUT in
		r|review )
			review
			;;
		t|tag )
			tag_select
			;;
		h|help )
			echo 'press r to review, press t for tag select, press h for help, press q to quit';;
		q|quit )
			echo "Quitting..."; break;;
		* )
			echo "What??";;
	esac
done
